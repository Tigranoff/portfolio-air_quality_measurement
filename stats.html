<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>IoT Statistics - Air Quality</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body { font-family: Arial, sans-serif; padding: 16px; }
    h1 { margin-bottom: 8px; }
    .metrics { display: grid; grid-template-columns: 1fr; gap: 12px; max-width: 1200px; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; border: 1px solid #ddd; text-align: left; }
    .charts { display: grid; grid-template-columns: repeat(2, 1fr); gap: 20px; margin-top: 20px; }
    .chart-container { background: #fff; border:1px solid #e0e0e0; border-radius: 6px; padding: 12px; }
    canvas { width: 100%; height: auto; }
    .note { color: #666; font-size: 14px; margin-top: 8px; }
    a.button { display:inline-block; margin-top:12px; padding:8px 12px; background:#24292e; color:#fff; text-decoration:none; border-radius:6px; }
    .button { background: #24292e; color: #fff; border: none; padding: 8px 12px; cursor: pointer; border-radius: 6px; }
    .data-controls { margin-bottom: 20px; }
    .url-load { display: flex; gap: 8px; }
    .url-load input { flex: 1; }
    .status { margin-top: 8px; font-size: 14px; color: #333; }
  </style>
</head>
<body>
  <a href="index.html" class="button">← Back</a>
  <h1>IoT Air Quality — Statistics</h1>

  <div class="metrics">
    <div id="summary">Loading...</div>

    <div class="charts">
      <div class="chart-container">
        <h3>Temperature (°C)</h3>
        <canvas id="tempChart"></canvas>
      </div>
      <div class="chart-container">
        <h3>PM2.5 (µg/m³)</h3>
        <canvas id="pmChart"></canvas>
      </div>
      <div class="chart-container">
        <h3>Humidity (%)</h3>
        <canvas id="humChart"></canvas>
      </div>
      <div class="chart-container">
        <h3>Pressure (hPa)</h3>
        <canvas id="presChart"></canvas>
      </div>
      <div class="chart-container">
        <h3>CO₂ (ppm)</h3>
        <canvas id="co2Chart"></canvas>
      </div>

      <div class="chart-container">
        <h3>TVOC (index)</h3>
        <canvas id="tvocChart"></canvas>
      </div>
      <div class="chart-container">
        <h3>PM10 (µg/m³)</h3>
        <canvas id="pm10Chart"></canvas>
      </div>
    </div>

    <section class="data-controls">
      <div id="status" class="status" aria-live="polite"></div>
    </section>
  </div>

  <script>
    // Load JSON via fetch
    async function loadJSONFetch(path) {
      try {
        const r = await fetch(path);
        if (!r.ok) throw new Error('not found');
        return await r.json();
      } catch (e) {
        return null;
      }
    }

    // Read File object
    function readFileJSON(file) {
      return new Promise((resolve, reject) => {
        if (!file) return resolve(null);
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const parsed = JSON.parse(reader.result);
            resolve(parsed);
          } catch (err) {
            reject(err);
          }
        };
        reader.onerror = () => reject(reader.error);
        reader.readAsText(file);
      });
    }

    function statsFor(values) {
      if (!values || !values.length) return null;
      const nums = values.filter(v => typeof v === 'number' && !isNaN(v));
      if (!nums.length) return null;
      const sum = nums.reduce((a,b)=>a+b,0);
      return {
        latest: +(nums[nums.length-1]).toFixed(2),
        min: +(Math.min(...nums)).toFixed(2),
        max: +(Math.max(...nums)).toFixed(2),
        avg: +(sum/nums.length).toFixed(2)
      };
    }

    function renderTable(stats) {
      const keys = Object.keys(stats);
      let html = '<table><thead><tr><th>Metric</th><th>Latest</th><th>Min</th><th>Max</th><th>Average</th></tr></thead><tbody>';
      keys.forEach(k=>{
        const s = stats[k];
        if (!s) {
          html += `<tr><td>${k}</td><td colspan="4">N/A</td></tr>`;
        } else {
          html += `<tr><td>${k}</td><td>${s.latest}</td><td>${s.min}</td><td>${s.max}</td><td>${s.avg}</td></tr>`;
        }
      });
      html += '</tbody></table>';
      document.getElementById('summary').innerHTML = html;
    }

    // helpers: high-DPI canvas sizing
    function resizeCanvasForDisplay(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(1, Math.floor(rect.width));
      const h = Math.max(1, Math.floor(rect.height));
      canvas.width = Math.floor(w * dpr);
      canvas.height = Math.floor(h * dpr);
      canvas.style.width = w + 'px';
      canvas.style.height = h + 'px';
      const ctx = canvas.getContext('2d');
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      return ctx;
    }

    function movingAverage(arr, n=5) {
      if (!Array.isArray(arr)) return [];
      const out = new Array(arr.length).fill(NaN);
      let sum = 0, cnt = 0;
      for (let i=0;i<arr.length;i++){
        const v = Number(arr[i]);
        if (Number.isFinite(v)) { sum += v; cnt++; }
        if (i>=n) {
          const old = Number(arr[i-n]);
          if (Number.isFinite(old)) { sum -= old; cnt--; }
        }
        if (cnt>0) out[i] = +(sum / cnt);
      }
      return out;
    }

    // smooth path via simple midpoint quadratic smoothing
    function drawSmoothPath(ctx, points) {
      if (!points.length) return;
      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length - 1; i++) {
        const xc = (points[i].x + points[i + 1].x) / 2;
        const yc = (points[i].y + points[i + 1].y) / 2;
        ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
      }
      const last = points[points.length - 1];
      ctx.lineTo(last.x, last.y);
      ctx.stroke();
    }

    // richer renderer: gradient fill, gridlines, smooth curve, MA overlay, points, latest badge
    function drawLine(canvas, data, color='#0074D9') {
      const ctx = resizeCanvasForDisplay(canvas);
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const pad = 28;
      const rect = canvas.getBoundingClientRect();
      const w = rect.width, h = rect.height;

      const nums = data.map(v => (typeof v === 'number' && !isNaN(v)) ? v : NaN);
      const vals = nums.filter(v => Number.isFinite(v));
      if (!vals.length) {
        ctx.fillStyle = '#999';
        ctx.font = '14px/1.2 system-ui, Arial, sans-serif';
        ctx.fillText('No data', 10, 22);
        return;
      }

      const min = Math.min(...vals), max = Math.max(...vals);
      const range = (max - min) || 1;

      // gridlines
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      ctx.lineWidth = 1;
      ctx.beginPath();
      const gridLines = 4;
      for (let i=0;i<=gridLines;i++){
        const y = pad + i * ((h - pad*2) / gridLines);
        ctx.moveTo(pad, y);
        ctx.lineTo(w - pad, y);
      }
      ctx.stroke();

      // compute points
      const stepX = (w - pad*2) / Math.max(1, nums.length - 1);
      const points = nums.map((v, i) => {
        const x = pad + i * stepX;
        const y = h - pad - ((Number.isFinite(v) ? v : min) - min) / range * (h - pad*2);
        return {x, y, v};
      });

      // gradient fill under curve
      const grad = ctx.createLinearGradient(0, pad, 0, h - pad);
      grad.addColorStop(0, color.replace('rgb','rgba').replace(')',',0.18)'));
      grad.addColorStop(1, color.replace('rgb','rgba').replace(')',',0.02)'));

      // draw filled smooth area
      ctx.beginPath();
      if (points.length === 1) {
        ctx.moveTo(points[0].x, points[0].y);
        ctx.lineTo(points[0].x, h - pad);
        ctx.lineTo(points[0].x, points[0].y);
      } else {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          const prev = points[i-1];
          const cur = points[i];
          const midX = (prev.x + cur.x) / 2;
          const midY = (prev.y + cur.y) / 2;
          ctx.quadraticCurveTo(prev.x, prev.y, midX, midY);
        }
        const last = points[points.length-1];
        ctx.lineTo(last.x, h - pad);
        ctx.lineTo(points[0].x, h - pad);
      }
      ctx.closePath();
      ctx.fillStyle = grad;
      ctx.fill();

      // draw main smooth stroke
      ctx.lineWidth = 2.5;
      ctx.strokeStyle = color;
      ctx.shadowColor = 'rgba(0,0,0,0.08)';
      ctx.shadowBlur = 6;
      drawSmoothPath(ctx, points);
      ctx.shadowBlur = 0;

      // draw MA overlay
      const ma = movingAverage(nums, Math.max(3, Math.round(nums.length/20)));
      const maPoints = ma.map((v,i)=>({x: pad + i*stepX, y: h - pad - (Number.isFinite(v) ? (v-min)/range*(h - pad*2) : 0), v}));
      ctx.lineWidth = 1.6;
      ctx.setLineDash([6,4]);
      ctx.strokeStyle = 'rgba(0,0,0,0.45)';
      drawSmoothPath(ctx, maPoints);
      ctx.setLineDash([]);

      // draw points
      for (let i=0;i<points.length;i++){
        const p = points[i];
        if (!Number.isFinite(p.v)) continue;
        ctx.beginPath();
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.4;
        ctx.arc(p.x, p.y, 3.2, 0, Math.PI*2);
        ctx.fill();
        ctx.stroke();
      }

      // value labels (max/min) at right
      ctx.fillStyle = '#333';
      ctx.font = '12px system-ui, Arial, sans-serif';
      ctx.textAlign = 'right';
      ctx.fillText(max.toFixed(2), w - pad - 6, pad + 6);
      ctx.fillText(min.toFixed(2), w - pad - 6, h - pad - 2);

      // latest value badge top-right
      const lastValidIndex = nums.map((v,i)=>Number.isFinite(v)?i:-1).filter(i=>i>=0).pop();
      if (lastValidIndex !== undefined && lastValidIndex >= 0) {
        const lastVal = nums[lastValidIndex];
        const badge = `${lastVal.toFixed(2)}`;
        const bw = ctx.measureText(badge).width + 20;
        const bh = 22;
        const bx = w - pad - bw;
        const by = pad - bh/2;
        ctx.fillStyle = 'rgba(0,0,0,0.75)';
        roundRect(ctx, bx, by, bw, bh, 6);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.font = '13px system-ui, Arial, sans-serif';
        ctx.fillText(badge, bx + bw/2, by + bh/2 + 5);
      }
    }

    // helper to draw rounded rect path
    function roundRect(ctx, x, y, w, h, r) {
      ctx.beginPath();
      ctx.moveTo(x + r, y);
      ctx.arcTo(x + w, y, x + w, y + h, r);
      ctx.arcTo(x + w, y + h, x, y + h, r);
      ctx.arcTo(x, y + h, x, y, r);
      ctx.arcTo(x, y, x + w, y, r);
      ctx.closePath();
    }

    function processReadings(readings) {
      if (!readings || !readings.length) {
        document.getElementById('summary').innerHTML = '<p>No readings found.</p>';
        return;
      }

      readings.sort((x, y) => new Date(x.timestamp) - new Date(y.timestamp));

      const temp = readings.map(r => Number(r.temperature));
      const press = readings.map(r => Number(r.pressure));
      const hum = readings.map(r => Number(r.humidity));
      const co2 = readings.map(r => Number(r.co2ppm ?? r.co2));
      const pm25 = readings.map(r => Number(r.pm2_5 ?? r.pm2));
      const pm10 = readings.map(r => Number(r.pm10));

      // Extract TVOC values from common keys (tvoc_index, tvoc, tvocIndex, tvoc_ppb)
      const tvoc = readings.map(r => {
        const v = r.tvoc_index ?? r.tvoc ?? r.tvocIndex ?? r.tvoc_ppb ?? r.tvoc_ppb ?? r.tvoc_ppm;
        return v === undefined ? NaN : Number(v);
      });

      const stats = {
        "Temperature (°C)": statsFor(temp),
        "Pressure (hPa)": statsFor(press),
        "Humidity (%)": statsFor(hum),
        "CO₂ (ppm)": statsFor(co2),
        "TVOC (index)": statsFor(tvoc),
        "PM2.5 (µg/m³)": statsFor(pm25),
        "PM10 (µg/m³)": statsFor(pm10)
      };

      renderTable(stats);

      // Draw all charts
      drawLine(document.getElementById('tempChart'), temp, '#e96464');
      drawLine(document.getElementById('pmChart'), pm25, '#4a90e2');
      drawLine(document.getElementById('humChart'), hum, '#9966cc');
      drawLine(document.getElementById('presChart'), press, '#ff9900');
      drawLine(document.getElementById('co2Chart'), co2, '#666666');
      drawLine(document.getElementById('tvocChart'), tvoc, '#ff66aa');
      drawLine(document.getElementById('pm10Chart'), pm10, '#00aa55');
    }

    (async function() {
      // Try to load both local files and merge readings (voc.json may contain tvoc values).
      const a = await loadJSONFetch('data_without_voc.json');
      const b = await loadJSONFetch('voc.json');
      const combined = [];
      if (a) {
        if (Array.isArray(a.readings)) combined.push(...a.readings);
        else if (Array.isArray(a)) combined.push(...a);
      }
      if (b) {
        if (Array.isArray(b.readings)) combined.push(...b.readings);
        else if (Array.isArray(b)) combined.push(...b);
      }

      if (combined.length) {
        processReadings(combined);
        return;
      }

      document.getElementById('summary').innerHTML = '<p>No data found. Place data_without_voc.json and voc.json next to this page.</p>';
    })();
  </script>
</body>
</html>